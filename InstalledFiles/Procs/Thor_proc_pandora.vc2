*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.20" SourceFile="thor_proc_pandora.vcx" CPID="1252" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS pg AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblFind" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkUseIndex" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkInc" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtFind" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: crecordsource_assign
		*m: dofiltergrid
		*m: editmemo
		*m: fontsize_assign
		*m: getgridwidth
		*m: getinputmask
		*m: getsortedstring		&& Sorts a string so that the longest words come first
		*m: hidecolumn
		*m: iscursor
		*m: istag
		*m: lcenter_assign
		*m: linputmask_assign
		*m: lreadonly_assign
		*m: lshowzero_assign
		*m: lzebra_assign
		*m: makecontrols
		*m: makeinputmask
		*m: makezebra
		*m: ngridwidth_access
		*m: nhighlightbackcolor_assign
		*m: nhighlightforecolor_assign
		*m: nzebracolor1_assign
		*m: nzebracolor2_assign
		*m: resolvemouse
		*m: setcaption
		*m: setdefaults
		*m: setgriddefaults
		*m: setproperties
		*m: sortgrid
		*m: visible_assign
		*p: calias
		*p: cback
		*p: ccursor
		*p: cmask
		*p: cmemo
		*p: cnosearchtext
		*p: cnulldisplay		&& Character(s) to show for null values
		*p: cnulldisplayold
		*p: crecordsource
		*p: csortfield
		*p: ctable
		*p: ctext
		*p: laskfortable
		*p: lautofit
		*p: lcenter
		*p: lcheckboxes
		*p: lenter
		*p: lfind
		*p: lincinprocess
		*p: lincrementalseek
		*p: linputmask
		*p: llocate
		*p: lmax
		*p: lnofind
		*p: lreadonly
		*p: lshownulls
		*p: lshowzero
		*p: lzebra
		*p: ncolmemobackcolor
		*p: ncolmemodisabledbackcolor
		*p: ngridwidth
		*p: nheaderbackcolor
		*p: nheadersortablebackcolor
		*p: nheadersortedbackcolor
		*p: nhidelast
		*p: nhighlightbackcolor
		*p: nhighlightforecolor
		*p: nincstart
		*p: nselect
		*p: nzebracolor1
		*p: nzebracolor2
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		calias = 
		Caption = "ProGrid"
		cback = 
		ccursor = 
		cmask = !
		cmemo = <Memo>
		cnosearchtext = No text entered! All records are shown.
		cnulldisplay = 
		cnulldisplayold = 
		crecordsource = 
		csortfield = 
		ctable = 
		ctext = 
		DoCreate = .T.
		FontSize = 9
		Height = 1117
		laskfortable = .F.
		lcenter = .F.
		lcheckboxes = .F.
		Left = 0
		lenter = .F.
		lfind = .F.
		lincinprocess = .F.
		lincrementalseek = .F.
		linputmask = .F.
		llocate = .T.
		lmax = .F.
		lnofind = .F.
		lreadonly = .F.
		lshownulls = .F.
		lshowzero = .F.
		lzebra = .T.
		MinWidth = 450
		Name = "pg"
		ncolmemobackcolor = 0
		ncolmemodisabledbackcolor = 0
		ngridwidth = 0
		nheaderbackcolor = 0
		nheadersortablebackcolor = 0
		nheadersortedbackcolor = 0
		nhidelast = 0
		nhighlightbackcolor = (rgb(210,210,210))
		nhighlightforecolor = 0
		nincstart = 2
		nselect = 0
		nzebracolor1 = 16777215
		nzebracolor2 = 16777158
		ScrollBars = 2
		ShowTips = .T.
		Top = 0
		Visible = .T.
		Width = 1600
		_memberdata = <VFPData>
			<memberdata name="caption" display="Caption"/>
			<memberdata name="ccursor" display="cCursor"/>
			<memberdata name="cnosearchtext" display="cNoSearchText"/>
			<memberdata name="dofiltergrid" display="doFilterGrid"/>
			<memberdata name="getsortedstring" display="getSortedString"/>
			<memberdata name="lmax" display="lMax"/>
			<memberdata name="nselect" display="nSelect"/>
			<memberdata name="setproperties" display="setProperties"/>
			<memberdata name="calias" display="cAlias"/>
			<memberdata name="csortfield" display="cSortField"/>
			<memberdata name="ctable" display="cTable"/>
			<memberdata name="ctext" display="cText"/>
			<memberdata name="lcenter" display="lCenter"/>
			<memberdata name="lcenter_assign" display="lCenter_Assign"/>
			<memberdata name="lreadonly" display="lReadOnly"/>
			<memberdata name="lreadonly_assign" display="lReadOnly_Assign"/>
			<memberdata name="lshowzero" display="lShowZero"/>
			<memberdata name="lshowzero_assign" display="lShowZero_Assign"/>
			<memberdata name="lzebra" display="lZebra"/>
			<memberdata name="lzebra_assign" display="lZebra_Assign"/>
			<memberdata name="makeinputmask" display="makeInputMask"/>
			<memberdata name="nheaderbackcolor" display="nHeaderBackColor"/>
			<memberdata name="nheadersortablebackcolor" display="nHeaderSortableBackColor"/>
			<memberdata name="nheadersortedbackcolor" display="nHeaderSortedBackColor"/>
			<memberdata name="nzebracolor1" display="nZebraColor1"/>
			<memberdata name="nzebracolor1_assign" display="nZebraColor1_Assign"/>
			<memberdata name="nzebracolor2" display="nZebraColor2"/>
			<memberdata name="nzebracolor2_assign" display="nZebraColor2_Assign"/>
			<memberdata name="setcaption" display="setCaption"/>
			<memberdata name="sortgrid" display="sortGrid"/>
			<memberdata name="makezebra" display="makeZebra"/>
			<memberdata name="crecordsource" display="cRecordSource"/>
			<memberdata name="crecordsource_assign" display="cRecordSource_Assign"/>
			<memberdata name="visible" display="Visible"/>
			<memberdata name="visible_assign" display="Visible_Assign"/>
			<memberdata name="fontsize" display="FontSize"/>
			<memberdata name="fontsize_assign" display="FontSize_Assign"/>
			<memberdata name="getinputmask" display="getInputMask"/>
			<memberdata name="iscursor" display="isCursor"/>
			<memberdata name="istag" display="isTag"/>
			<memberdata name="linputmask" display="lInputMask"/>
			<memberdata name="linputmask_assign" display="lInputMask_Assign"/>
			<memberdata name="name" display="Name"/>
			<memberdata name="lautofit" display="lAutofit"/>
			<memberdata name="editmemo" display="editMemo"/>
			<memberdata name="makecontrols" display="makeControls"/>
			<memberdata name="cmemo" display="cMemo"/>
			<memberdata name="getgridwidth" display="getGridWidth"/>
			<memberdata name="ngridwidth" display="nGridWidth"/>
			<memberdata name="ngridwidth_access" display="nGridWidth_Access"/>
			<memberdata name="cmask" display="cMask"/>
			<memberdata name="nhighlightbackcolor" display="nHighlightBackColor"/>
			<memberdata name="nhighlightbackcolor_assign" display="nHighlightBackColor_Assign"/>
			<memberdata name="nhighlightforecolor" display="nHighlightForeColor"/>
			<memberdata name="nhighlightforecolor_assign" display="nHighlightForeColor_Assign"/>
			<memberdata name="minwidth" display="MinWidth"/>
			<memberdata name="hidecolumn" display="hideColumn"/>
			<memberdata name="resolvemouse" display="resolveMouse"/>
			<memberdata name="lshownulls" display="lShowNulls"/>
			<memberdata name="cnulldisplay" display="cNullDisplay"/>
			<memberdata name="cnulldisplayold" display="cNullDisplayOld"/>
			<memberdata name="lnofind" display="lNoFind"/>
			<memberdata name="lfind" display="lFind"/>
			<memberdata name="setdefaults" display="SetDefaults"/>
			<memberdata name="ncolmemobackcolor" display="nColMemoBackColor"/>
			<memberdata name="ncolmemodisabledbackcolor" display="nColMemoDisabledBackColor"/>
			<memberdata name="setgriddefaults" display="setGridDefaults"/>
			<memberdata name="lincrementalseek" display="lIncrementalSeek"/>
			<memberdata name="lincinprocess" display="lIncInProcess"/>
			<memberdata name="laskfortable" display="lAskForTable"/>
			<memberdata name="lenter" display="lEnter"/>
			<memberdata name="nhidelast" display="nHideLast"/>
			<memberdata name="llocate" display="lLocate"/>
			<memberdata name="nincstart" display="nIncStart"/>
			<memberdata name="lcheckboxes" display="lCheckboxes"/>
			<memberdata name="width" display="Width"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'chkInc' AS checkbox WITH ;
		Alignment = 0, ;
		Anchor = 9, ;
		AutoSize = .F., ;
		Caption = "\<Inc. seek (*)", ;
		ControlSource = "thisform.lIncrementalSeek", ;
		Height = 17, ;
		Left = 1500, ;
		Name = "chkInc", ;
		Top = 24, ;
		Value = .F., ;
		Width = 83
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'chkUseIndex' AS checkbox WITH ;
		Alignment = 0, ;
		Anchor = 9, ;
		AutoSize = .F., ;
		Caption = "\<Use index (!)", ;
		Height = 17, ;
		Left = 1500, ;
		Name = "chkUseIndex", ;
		Top = 7, ;
		Value = .F., ;
		Width = 87
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'grd' AS grid WITH ;
		Anchor = 15, ;
		Height = 876, ;
		HighlightBackColor = 192,192,255, ;
		HighlightForeColor = 0,0,0, ;
		HighlightStyle = 2, ;
		Left = 0, ;
		Name = "grd", ;
		TabIndex = 1, ;
		Themes = .F., ;
		Top = 46, ;
		Width = 1164
		*< END OBJECT: BaseClass="grid" />

	ADD OBJECT 'lblFind' AS label WITH ;
		Alignment = 1, ;
		Anchor = 3, ;
		Caption = "\<Find", ;
		Height = 17, ;
		Left = 4, ;
		Name = "lblFind", ;
		TabIndex = 8, ;
		Top = 15, ;
		Width = 45, ;
		ZOrderSet = 7
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'txtFind' AS textbox WITH ;
		Anchor = 11, ;
		Height = 25, ;
		Left = 60, ;
		Name = "txtFind", ;
		TabIndex = 9, ;
		Top = 12, ;
		Width = 1428, ;
		ZOrderSet = 6
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE Activate
		this.lZebra = this.lZebra 
		If this.lFind 
		*!*			Keyboard '{ALT+F}' plain
		EndIf
	ENDPROC

	PROCEDURE crecordsource_assign
		lparameters tcRecordSource
		If !Empty(Justext(tcRecordSource)) && Alias
		   This.Grd.RecordSourceType = 0
		Else 
			this.Grd.RecordSourceType = 1    
		Endif
		This.cRecordSource = tcRecordSource
		this.cTable = JustStem(this.cRecordSource)
		ThisForm.setCaption()
	ENDPROC

	PROCEDURE Destroy
		Use in (Select(this.cCursor))
		Set Filter To 
		On Key Label ESC
	ENDPROC

	PROCEDURE dofiltergrid
		Lparameters tcText
		Local laFields[1], laFtypes[1], lcText, lcValue, lcWord, llFound, lnFields, lnRecord, lnWord, lnX
		lcText = Upper(Alltrim(m.tcText))
		If Len(m.lcText ) = 0 && or m.lcText == this.cMask
			this.txtFind.Value = ''
		*!*	   Wait Window Thisform.cNoSearchText
		   Select (this.cTable)
		   Set Filter To 
		   this.lZebra = .T.
		   this.Grd.SetFocus()
		   Return
		EndIf
		If !thisform.lIncrementalSeek 
			Wait Window 'Search in process...' nowait
		Endif
		lcCrlf = Chr(13)+Chr(10)
		Thisform.nSelect = Select()
		lnRec = Recno()
		Select 0
		Create Cursor (Thisform.cCursor ) (Record i)
		Index On Record Tag Record
		Select (Thisform.nSelect )
		Set Filter To
		lcPoint = Set("Point")
		Set Point To '.'
		lnFields = Afields(laFields)
		Dimension m.laFtypes(m.lnFields)
		For lnX = 1 To m.lnFields
		   laFtypes(m.lnX) = Vartype(Evaluate(Field(m.lnX)))
		EndFor
		For lnWord = 1 To Getwordcount(m.lcText)
		   lcWord = Getwordnum(m.lcText, m.lnWord)
		   If m.lnWord > 1
		      Set Relation To Recno() Into (Thisform.cCursor)
		      Set Filter To !Eof(Thisform.cCursor )
		   EndIf
		   If m.lnWord = 1 and ((Left(m.lcWord,1) = thisform.cMask and Len(m.lcWord) > 1) or !Empty(this.chkUseIndex.Value))
		   	If Left(m.lcWord,1) = thisform.cMask
			   	m.lcWord = Substr(m.lcWord ,2)
		   	Endif
		   	lnWordVal = Val(m.lcWord)
		   	lcCurDummy = 'cur_'+Sys(2015)
		   	lcSql = Textmerge('Select Cast(Recno() as i) as record from <<Alias()>> where ')
		   	lnTags = ATagInfo(laTags)
		   	For lnX = 1 to Tagcount()
		   		lcExpression = m.laTags(m.lnX,3)
		   		If '+'$m.lcExpression or '"'$m.lcExpression or !Empty(m.laTags(lnX,4))
		   			Loop
		   		EndIf
		   		m.lcType = Type('Evaluate(laTags(m.lnX,3))')
		    		Do Case
		   			Case InList(m.lcType ,'L','D','T','G','M','Q','W','Y')
		   				Loop
		   		   Case m.lcType = 'N' 
		   		   	If m.lnWordVal > 0
			   		   	m.lcSql = Textmerge( '<<m.lcSql>>; <<lcCrlf>> <<laTags(m.lnX,3)>> = <<m.lnWordVal>>')
			   		   Else
			   		   	loop
		   		   	Endif
		   		   Otherwise
		   		   	m.lcSql = Textmerge( '<<m.lcSql>>; <<lcCrlf>> <<laTags(m.lnX,3)>> = [<<m.lcWord>>]')
		   		EndCase
		   		If m.lnX < m.lnTags
		   			m.lcSql = m.lcSql + ' or '
		   		EndIf
		   	EndFor
		   	If Right(m.lcSql,4) = ' or '
		   		m.lcSql = Left(m.lcSql ,Len(m.lcSql)-4)
		   	Endif
		   	m.lcSql = Textmerge('<<m.lcSql>> into cursor <<m.lcCurDummy>> readwrite')
		   	_screen.AddProperty('sql',m.lcSql) 
		   	ExecScript(lcSql)
		   	If _tally>0
		   		Select (thisform.cCursor)
		   		Append from dbf(lcCurDummy)
		   		Use in (m.lcCurDummy)
		   	Endif
		   else
			   Scan
			      llFound = .F.
			      For lnX = 1 To m.lnFields
			         lcValue = Evaluate(Field(m.lnX))
			         Do Case
			            Case Inlist(Vartype(m.lcValue), [G], [L], [Q])
			               Loop
			            Case Vartype(m.lcValue) # [C]
			               lcValue = Transform(m.lcValue)
			            Otherwise
			         Endcase
			         lcValue = Upper(m.lcValue)
			         lnRecord = Recno()
			         If m.lcWord $ m.lcValue
			            If m.lnWord = 1
			               Insert Into (Thisform.cCursor) (Record) Values (m.lnRecord)
			            Endif
			            llFound = .T.
			            Exit
			         Endif
			      Endfor
			      If !m.llFound And m.lnWord > 1
			         Delete In (Thisform.cCursor)
			      Endif
			   EndScan
		   Endif
		   Select * From (Thisform.cCursor) Into Cursor (Thisform.cCursor) Readwrite Where !Deleted()
		   Index On Record Tag Record
		   Select (Thisform.nSelect)
		EndFor
		If !thisform.lIncrementalSeek 
			Wait clear
		Endif
		Set Point To m.lcPoint 
		Set Relation To Recno() Into (Thisform.cCursor )
		Set Filter To !Eof(Thisform.cCursor )
		Thisform.lZebra = .F.
		*Go Top
		If thisform.lLocate
			Locate
		Else
			Go m.lnRec 
		Endif
		*!*	Endif !this.lIncrementalSeek
		this.grd.Refresh()
		*!*	If thisform.lIncrementalSeek 
		*!*	*!*		thisform.txtFind.SetFocus()
		*!*	else	
		*!*		Thisform.Grd.Refresh()
		*!*		Thisform.Grd.SetFocus()
		*!*	Endif
		
	ENDPROC

	PROCEDURE editmemo
		Local lcField
		Local laEvents[1], loHeader
		Local laDummy[1], lnHeight, lnWidth, lnX
		
		Aevents( laEvents, 0 )
		m.loHeader = m.laEvents[ 1 ]
		m.lcField = m.loHeader.Parent.ControlSource
		m.lnHeight = Alines(laDummy, Evaluate(m.lcField))
		m.lnWidth = 1
		For m.lnX = 1 To m.lnHeight
		  If Len(m.laDummy(m.lnX)) > m.lnWidth
		    m.lnWidth = Len(m.laDummy(m.lnX))
		  Endif
		Endfor
		m.lnWidth = Min(m.lnWidth, 200)
		m.lnHeight = Min(m.lnHeight + 5, 25)
		lcText = Evaluate( m.lcField)
		Define Window loWindow From 1, 1 Size m.lnHeight, m.lnWidth Font This.FontName, This.FontSize;
		  Title Justext(m.lcField) Close Float Grow
		Move Window loWindow Center
		If Thisform.lReadOnly
		  If !Empty(m.lcText)
		    Modify Memo (m.lcField) Window loWindow Noedit
		  Endif
		Else
		  Modify Memo (m.lcField) Window loWindow Nowait
		Endif
		
	ENDPROC

	PROCEDURE fontsize_assign
		lparameters tFontSize
		This.FontSize = tFontSize
		If Vartype(this.grd)='O' and PemStatus(this.Grd,'column1',5)
			this.Grd.FontSize = m.tFontSize
			this.Grd.Refresh()
		Endif
		
	ENDPROC

	PROCEDURE getgridwidth
		lnWidth = this.Grd.GridLineWidth 
		lnLineWidth = this.Grd.GridLineWidth
		For lnX = 1 to this.Grd.ColumnCount
			If this.Grd.Columns(lnX).visible 
				m.lnWidth = m.lnWidth + this.Grd.Columns(m.lnX).width
				If this.Grd.GridLines>1
					m.lnWidth = m.lnWidth + m.lnLineWidth 
				Endif
			Endif
		EndFor
		If this.Grd.DeleteMark 
			m.lnWidth = m.lnWidth + 10
		EndIf
		If this.Grd.RecordMark
			m.lnWidth = m.lnWidth + 8
		EndIf
		If this.Grd.ScrollBars>1
			m.lnWidth = m.lnWidth + Sysmetric(5) + 2*m.lnLineWidth 
		EndIf
		Return m.lnWidth + 2 	
	ENDPROC

	PROCEDURE getinputmask
		Lparameters taDummy, tnElement
		Local lcMask, lcMaster, lcType, lnDecimals, lnInteger, lnWidth
		lcType = m.taDummy(m.tnElement, 2)
		lcMask = []
		Do Case
		   Case m.lcType = [I] && Integer
		      lcMask = [99 999 999 999]
		   Case m.lcType = [Y] && Currency
		      lcMask = [999 999 999 999 999.999]
		   Case m.lcType = [N] && Numeric
		      lnWidth = m.taDummy(m.tnElement, 3)
		      lnDecimals = m.taDummy(m.tnElement, 4)
		      If m.lnDecimals > 0
		         lnInteger = m.lnWidth - m.lnDecimals - 1
		      Else
		         lnInteger = m.lnWidth
		      Endif
		      lcMaster = [999 999 999 999]
		      Do Case
		         Case m.lnInteger >= 10
		            lcMask = Right(m.lcMaster, m.lnInteger + 3)
		         Case m.lnInteger >= 7
		            lcMask = Right(m.lcMaster, m.lnInteger + 2)
		         Case m.lnInteger >= 4
		            lcMask = Right(m.lcMaster, m.lnInteger + 1)
		         Otherwise
		            lcMask = Right(m.lcMaster, m.lnInteger)
		      Endcase
		      If m.lnDecimals > 0
		         lcMask = m.lcMask + [.] + Replicate([9], m.lnDecimals)
		      Endif
		Endcase
		lcMask = chrtran(lcMask,' ,',Set("Separator")+Set("Point"))
		Return m.lcMask
		
	ENDPROC

	PROCEDURE getsortedstring		&& Sorts a string so that the longest words come first
		Parameters tcText
		Local laDummy[1], lcReturn, lnWord, lnX
		lnWord = Getwordcount(m.tcText )
		Dimension m.laDummy(m.lnWord, 2)
		For lnX = 1 To m.lnWord
		   laDummy(m.lnX, 1) = Getwordnum(m.tcText, m.lnX )
		   laDummy(m.lnX, 2) = Len(m.laDummy(m.lnX, 1))
		Endfor
		Asort(m.laDummy, 2, 0, 1)
		lcReturn = []
		For lnX = 1 To m.lnWord
		   lcReturn = m.lcReturn + [ ] + m.laDummy(m.lnX, 1)
		Endfor
		Return Alltrim(m.lcReturn )
	ENDPROC

	PROCEDURE hidecolumn
		Local laEvents[1], loHeader As Header
		Local lnWidth
		lnWidth = 15
		Aevents( laEvents, 0 )
		If laEvents(1).Baseclass = 'Header'
			loHeader = laEvents[ 1 ]
			If loHeader.Parent.Width = m.lnWidth
			   loHeader.Parent.AutoFit()
			   this.grd.LockColumns = 0
			Else
			   loHeader.Parent.Width = m.lnWidth
			EndIf
			This.Resize()
		Endif
		
		
	ENDPROC

	PROCEDURE Init
		Lparameters tcParameter
		*A: Ask for table if none selected
		*C: Show checkboxes incseek and index
		*E: Exit with Enter
		*F: Activate Find on startup
		*I: Incremental seek
		*M: "nice" numbers
		*N: Hide Find option (same as f)
		*S: Incremental seek starts after x=number of S's characters
		*U: Autofit
		*W: ReadWrite
		*Z: Hide zero values
		*0: (numeric): Incremental seek starts at first character
		*1: Standard modal
		 
		If Pcount()= 0 and Vartype(_screen.lParameters) = 'L' and _screen.lParameters && For interactive testing
			If Empty(Alias())
				Use kundtest In Select('kundtest')
				Select kundtest
			Endif Empty(Alias())
			lnParCount = 1
			tcParameter = 'FI'
		Else 
			m.lnParCount = Pcount()
		EndIf
		ThisForm.SetDefaults()
		If m.lnParCount > 0
			this.lAskForTable = 'A'$Upper(m.tcParameter) 
			this.lCheckboxes = 'C'$Upper(m.tcParameter)
			this.lEnter  = 'E'$Upper(m.tcParameter)
			this.lFind = 'F'$Upper(m.tcParameter)
			this.lIncrementalSeek = 'I'$Upper(m.tcParameter)
			this.lNoFind = 'N'$Upper(m.tcParameter)
			this.lReadOnly = !'W'$Upper(m.tcParameter)
			this.lShowZero = !'Z'$Upper(m.tcParameter)
			this.nHideLast = Occurs('L',Upper(m.tcParameter))
			this.lInputMask = 'M'$Upper(m.tcParameter)
			this.lAutofit = 'U'$Upper(m.tcParameter)
			If '0'$m.tcParameter && Number
				this.nIncStart = 0
			EndIf
			If 'S'$Upper(m.tcParameter)
				this.nIncStart = Occurs('S',Upper(m.tcParameter))
			Endif
		Endif
		Do case 
			Case m.lnParCount = 0
			Case '1' $ m.tcParameter && Standard modal
				this.lIncrementalSeek = .T.
				this.lEnter = .T.
				this.lInputMask = .T.
				this.lAutofit = .T.
			Case this.lNoFind   && Hide Find option
				this.grd.Top = 0
		*!*			this.grd.Refresh()
				this.txtFind.Visible = .F.
				this.lblFind.Visible = .F.
			Case this.lFind && Activate Find 
		Endcase
		If this.lEnter && Enter exits
			this.lIncrementalSeek = .T.
			this.chkInc.Visible = .F.
			this.chkUseIndex.Visible = .F.
			this.lFind = .T.
		Endif
			
		If _vfp.StartMode = 0 && Design mode
		Else
			this.Width = Sysmetric(1)/2
			this.Height = Sysmetric(2)/2
		Endif
		This.AutoCenter = .T.
		llSuccess = .T.
		If Empty(Alias())
			If this.lAskForTable 
				lcTable = GetFile('dbf')
				If Empty(m.lcTable)
					m.llSuccess = .F.
				Else 
					Select Select(JustStem(m.lcTable))
					Use (lcTable)
		*!*				Return .f. && TBFix 
				EndIf
			Else 
				m.llSuccess = .F.
			EndIf
			If !m.llSuccess 
				messagebox( 'No table is selected!',0+16)
				Return .F.
			Endif
		EndIf
		this.cRecordSource = Alias()
		Go top in (this.cRecordSource)
		this.grd.RecordSource = this.cRecordSource 
		If IsReadonly()
			this.lReadOnly = .T.
			this.Grd.DeleteMark = .F.
		Endif
		
		If this.lAutofit 
			this.Grd.AutoFit()
		Endif
		this.makeControls()
		this.getGridWidth()
		
		this.cNullDisplayOld = Set("Nulldisplay")
		On Key Label ESC Keyboard '{CTRL+F4}' plain
		this.cCursor = 'Cur_' + Sys(2015)
		this.Resize()
		this.AutoCenter = this.AutoCenter 
	ENDPROC

	PROCEDURE iscursor
		Return (justpath(dbf(alias())) = sys(2023)) and JustExt(Dbf(Alias())) = 'TMP'
	ENDPROC

	PROCEDURE istag
		Lparameters tcTagName, tcTable 
		*-- Passed the name of an index tag returns true if it is a tag for the specified table. Uses table in the current work area if no table name is passed.
		  LOCAL ARRAY laTags[1]
		  LOCAL llRetVal
		  *** Did we get a tag name?
		  IF TYPE( 'tcTagName' ) # 'C'
		    *** Error - must pass a Tag Name
		    ERROR '9000: Must Pass a Tag Name when calling ISTAG()'
		    RETURN .F.
		  ENDIF
		  *** How about a table alias?
		  IF TYPE( 'tcTable' ) = 'C' AND ! EMPTY( tcTable )
		      *** Get all open indexes for the specified table
		      ATagInfo( laTags, "", tcTable )
		  ELSE
		      *** Get all open indexes for the current table
		      ATagInfo( laTags, "" )
		  ENDIF
		
		  *** Do a Case Insensitive, Exact=ON, Scan of the first column of array
		  *** Return Whether the Tag is Found or not
		  RETURN ( ASCAN( laTags, tcTagName, -1, -1, 1, 7 ) > 0 )
	ENDPROC

	PROCEDURE lcenter_assign
		lparameters tlCenter
		If m.tlCenter 
			this.Left = (Sysmetric(1) - this.Width)/2
			this.Top = (Sysmetric(2) - this.Height)/2
		Endif
		This.lCenter = tlCenter
		
	ENDPROC

	PROCEDURE linputmask_assign
		lparameters tlInputMask
		This.lInputMask = tlInputMask
		this.setProperties()
		
	ENDPROC

	PROCEDURE Load
		thisform.setGridDefaults() 
		
	ENDPROC

	PROCEDURE lreadonly_assign
		lparameters tlReadOnly
		This.lReadOnly = tlReadOnly
		this.setProperties()
	ENDPROC

	PROCEDURE lshowzero_assign
		lparameters tlShowZero
		This.lShowZero = tlShowZero
		this.setProperties()
	ENDPROC

	PROCEDURE lzebra_assign
		lparameters tlZebra
		This.lZebra = tlZebra
		this.setProperties()
	ENDPROC

	PROCEDURE makecontrols
		Local laDummy[1], lnFields, lnX
		Local loCol As Column, loChk As Checkbox
		Local lcCol as column, lcField, lcName
		Local loControl as CheckBox 
		m.lnFields = Afields(laDummy)
		For m.lnX = 1 To m.lnFields
		  m.lcField = Field(m.lnX)
		  m.lcCol = Textmerge([thisform.Grd.Columns(<<m.lnX >>)])
		  If Inlist(Type(m.lcField), [L], [M])
		    m.loCol = Evaluate(m.lcCol)
		    Do Case
		      Case Type(m.lcField) = [L]
		        m.lcName = [chk]
		        m.loCol.AddObject(m.lcName, [CheckBox])
		        m.loControl = Evaluate(m.lcCol + [.] + m.lcName)
		        m.loControl.Caption = []
		        m.loCol.CurrentControl = m.lcName
		        m.loCol.Alignment = 2
		      Case Type(m.lcField) = [M] 
		        m.loCol.Alignment = 2
		        thisform.cback = Textmerge('iif(Empty(Evaluate("<<this.Grd.RecordSource>>.<<m.lcField>>")),<<thisform.nColMemoDisabledBackColor>>,<<thisform.nColMemoBackColor>>)')
		        m.loCol.DynamicBackColor = this.cback
						BindEvent(m.loCol.text1 ,"Click",thisform,"editMemo",1)  
		      Otherwise && Won't happen, just in case...
		    Endcase
		    m.loCol.Sparse = .F.
		  EndIf
		EndFor
		thisform.grd.ColumnCount = Max(thisform.grd.ColumnCount - thisform.nHideLast, 1)
		
	ENDPROC

	PROCEDURE makeinputmask
		Local laDummy[1], lcMask, lnFields, lnX
		lnFields = Afields(laDummy)
		For lnX = 1 To this.Grd.ColumnCount && m.lnFields
			   lcMask = This.Getinputmask(@m.laDummy, m.lnX)
			   If !Empty( m.lcMask )
			   	this.Grd.Columns(lnX).InputMask = m.lcMask
			   Endif
			Endfor
		
	ENDPROC

	PROCEDURE makezebra
		If this.lZebra and Empty(Set("Order"))
			lcText = Textmerge([IIF(Recno()%2 = 0, <<thisform.nZebraColor1>>, <<thisform.Nzebracolor2>> )]) 
		Else
			lcText = ''
		EndIf
		For lnX = 1 to thisform.Grd.ColumnCount 
			With this.Grd.Columns(lnX)
				If Empty(.DynamicBackColor)
					.DynamicBackColor = m.lcText 
				Endif
			Endwith
		Endfor
		
	ENDPROC

	PROCEDURE ngridwidth_access
		return this.getGridWidth()
		
	ENDPROC

	PROCEDURE nhighlightbackcolor_assign
		lparameters tnHighlightBackColor
		This.nHighlightBackColor = tnHighlightBackColor
		this.setProperties()
	ENDPROC

	PROCEDURE nhighlightforecolor_assign
		lparameters tnHighlightForeColor
		This.nHighlightForeColor = tnHighlightForeColor
		this.setProperties ()
	ENDPROC

	PROCEDURE nzebracolor1_assign
		lparameters tnZebraColor1
		This.nZebraColor1 = tnZebraColor1
		this.setProperties()
	ENDPROC

	PROCEDURE nzebracolor2_assign
		lparameters tnZebraColor2
		This.nZebraColor2 = tnZebraColor2
		this.setProperties()
	ENDPROC

	PROCEDURE Release
		Set Nulldisplay To this.cNullDisplayOld
		Select (this.cRecordSource)
		Set Filter To 
		On Key Label ESC 
		
	ENDPROC

	PROCEDURE Resize
		Local lnGridWidth
		lnGridWidth = This.nGridWidth
		
		If This.Width > lnGridWidth
		   This.Width = lnGridWidth
		Endif
		
		
	ENDPROC

	PROCEDURE resolvemouse
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		Do Case
		   Case nButton = 1 && LeftClick
				thisform.sortGrid()
		   Case nButton = 2 and nShift = 0 && RightClick
				thisform.hideColumn()
		   Case nButton = 2 and nShift = 1 &&RightClick + shift
		   Otherwise
		Endcase
	ENDPROC

	PROCEDURE setcaption
		If this.isCursor()
			this.Caption = Proper(Alias())
		Else
			This.Caption = Proper(Juststem(This.cRecordSource))
		EndIf
		this.cAlias = this.Caption 
	ENDPROC

	PROCEDURE setdefaults
		this.lAskForTable = .F.
		this.lNoFind = .F.
		this.lReadOnly = .F.
		this.lShowZero = .F.
		this.lFind = .F.
		this.lIncrementalSeek = .F.
		this.lEnter = .F.
		this.nHideLast = 0
		*Note thisform.Load calls setGridDefaults() 
	ENDPROC

	PROCEDURE setgriddefaults
		this.nHighlightBackColor = Rgb(210,210,210) 
		this.nHighlightForeColor = 0
		this.FontSize = 10
		this.nColMemoBackColor = Rgb(127,255,127)
		this.nColMemoDisabledBackColor = Rgb(240,240,240)
		this.nHeaderSortableBackColor = Rgb(255,255,220)
		this.nHeaderSortedBackColor = Rgb(220,255,220) 
		this.nHeaderBackColor =  RGB(255,220,220) 
	ENDPROC

	PROCEDURE setproperties
		*!*	ThisForm.MakeZebra()
		If thisform.lShowNulls
			Set Nulldisplay To 
		Else
			Set Nulldisplay To thisform.cNullDisplay
		Endif
		If PemStatus(this,'grd',5) and PemStatus(this.Grd,'column1',5)
			* Vartype(this.grd) = 'O' and Lower(this.Grd.BaseClass) = 'grid'
			If PemStatus(this,'grd',5)
				If this.lShowZero 
					this.Grd.SetAll('format','','column')
				Else
					this.Grd.SetAll('format','Z','column')
				EndIf
				this.Grd.readOnly = Nvl(this.lReadOnly,.F.)
				this.Grd.DeleteMark = !this.lReadOnly and !IsReadonly()
				If this.lInputMask
					this.makeInputMask()
				Else 
					this.Grd.SetAll('InputMask','','column')	
				EndIf
				this.grd.HighlightBackColor = this.nHighlightBackColor 
				this.grd.HighlightForeColor = this.nHighlightForeColor 
			Endif
			ThisForm.MakeZebra()
		Endif
		
		
	ENDPROC

	PROCEDURE Show
		LPARAMETERS nStyle
		If thisform.lFind 
				Keyboard '{ALT+F}' plain
		EndIf
		
	ENDPROC

	PROCEDURE sortgrid
		Local laEvents[ 1 ], loHeader, lcField, loColumn, lcSortOrder, loControl as Header 
		Local llFoundColumn, llAllowCellSelection, lnRecNo
		Local lcTable
		
		*** First of all, see which column fired off this event
		Aevents( laEvents, 0 )
		loHeader = laEvents[ 1 ]
		If Vartype( loHeader ) = [O]
		   *** First See if a ControlsSource was set for the column
		   With loHeader.Parent
		      lcField = []
		      If Not Empty( .ControlSource )
		         *** Cool. Use it to decide how to sort the grid
		         If Not Empty( .ControlSource ) And ( [.] $ .ControlSource ) And Not( [(] $ .ControlSource )
		            lcField = Justext( .ControlSource )
		         Endif
		      Endif
		   Endwith
		   *** we have a field - let's see if it already has a sort order set
		   *** if it does, it will have the appropriate picture in the header
		   lcSortOrder = []
		   If Not Empty( loHeader.Picture )
		      lcSortOrder = Iif( Lower( Justfname( loHeader.Picture ) ) == [up.bmp], [], [DESC] )
		   Else
		      *** See if there is a visual cue on any of the other grid
		      *** column headers and remove it if there is
		      For Each loColumn In This.Grd.Columns
		         For Each loControl In loColumn.Controls
		            If Lower( loControl.BaseClass ) == [header]
		               If Not Empty( loControl.Picture )
		                  llFoundColumn = .T.
		                  loControl.Picture = []
		                  loControl.FontBold = .F.
		                  If loControl.BackColor = this.nHeaderSortedBackColor 
		                  	loControl.BackColor = this.nHeaderSortableBackColor 
		                  Endif
		               Endif
		            Endif
		         Endfor
		         If llFoundColumn
		            Exit
		         Endif
		      Endfor
		   Endif
		
		   *** if we have a field - let's sort
		   If Not Empty( lcField )
		      *** There seems to be a refresh issue here
		      *** because even though the data is in the cursor
		      *** it is not showing up in the grid after the sort
		      *** and it looks like it is related to AllowCellSelection being .F.
		      llAllowCellSelection = This.Grd.AllowCellSelection
		      This.Grd.AllowCellSelection = .F.
		      This.Grd.Refresh()
		      Keyboard [{CTRL+TAB}]
		
		      *** Check to see if the tag exists assume
		      *** that if there is a tag on this field, it has the same name as the field
		      lcTable = Juststem(This.Grd.RecordSource)
		      If This.IsTag( lcField, m.lcTable  )
		         lnRecNo = Recno( m.lcTable )
		         *** Go ahead and set the order for the table
		         Select ( lcTable)
		         If Empty(m.lcSortOrder) 
			         Set Order To ( lcField ) 
			      Else
			         Set Order To ( lcField ) DESCENDING 
		         Endif
		*!*	         This.Grd.SetFocus()
		         If lnRecNo # 0
		            Go lnRecNo In ( lcTable )
		         Endif
		         *** And set the visual cues on the header
		         loHeader.Picture = Iif( !Empty( lcSortOrder ), [..\images\up.bmp], [..\images\down.bmp] )
		         loHeader.FontBold = .T.
		         loHeader.BackColor = this.nHeaderSortedBackColor 
		         This.Grd.AllowCellSelection = llAllowCellSelection
		*!*	         Endif
				Else
					Set Order to 
		      EndIf
		   Endif
		Endif 
		*!*	If this.lAutofit
		*!*		this.grd.AutoFit()
		*!*	Endif
		this.makeZebra()
		this.Grd.Refresh()
	ENDPROC

	PROCEDURE Unload
		If this.WindowType = 1 and !Empty(thisform.cRecordSource)
			Return Recno(Alias())
		Endif
		
	ENDPROC

	PROCEDURE visible_assign
		lparameters tVisible
		This.Visible = tVisible
		this.Grd.SetFocus()
	ENDPROC

	PROCEDURE chkInc.InteractiveChange
		this.Parent.txtFind.SetFocus()
	ENDPROC

	PROCEDURE chkInc.LostFocus
		this.Parent.txtFind.Refresh()
	ENDPROC

	PROCEDURE chkInc.Refresh
		this.Visible = thisform.lCheckboxes
	ENDPROC

	PROCEDURE chkUseIndex.InteractiveChange
		this.Parent.txtFind.SetFocus()
	ENDPROC

	PROCEDURE chkUseIndex.Refresh
		this.Visible = thisform.lCheckboxes 
	ENDPROC

	PROCEDURE grd.Init
		With this.Parent 
		*!*		this.Top = 0
			this.Left = 0
			this.Width = .Width
			this.Height = .Height - 45
		EndWith
		*!*	ThisForm.setGridDefaults()
		For lnX = 1 to this.ColumnCount
			If thisform.isTag(Justext(this.Columns(lnX).controlsource), thisform.cAlias )
				this.Columns(lnX).header1.backcolor = thisform.nHeaderSortableBackColor 
			Else
				this.Columns(lnX).header1.backcolor = thisform.nHeaderBackColor
			Endif
			BindEvent(this.Columns(lnX).header1,'mousedown',thisform,'resolveMouse')	
		EndFor
		this.Refresh()
		
	ENDPROC

	PROCEDURE grd.Refresh
		if thisform.lNoFind 
			this.Top = 0
			this.Height = thisform.Height 
		Else
			this.Top = 45
		endif		
	ENDPROC

	PROCEDURE grd.Resize
		if thisform.lNoFind 
			this.Top = 0
			this.Height = thisform.Height 
		Else
			this.Top = 45
		endif		
		*!*	If thisform.lMax 
		*!*		lnDiff = 0
		*!*	Else
		*!*		lnDiff = 45
		*!*	Endif
		*!*	this.Height = thisform.Height - m.lnDiff 
		
	ENDPROC

	PROCEDURE lblFind.Refresh
		this.Enabled = !thisform.lMax 
	ENDPROC

	PROCEDURE txtFind.KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		lnSelstart = this.SelStart 
		llGrid = .F.
		NoDefault 
		Do case
			Case m.nKeyCode = 5 and m.nShiftAltCtrl = 0 && Up
				Try 
					Skip -1
			catch
		
				Endtry
				m.llGrid = .T.
			Case m.nKeyCode = 24 and m.nShiftAltCtrl = 0 && Down
				Try 
				  Skip 1
				catch
				EndTry
		
				m.llGrid = .T.
			Case m.nKeyCode = 18 and m.nShiftAltCtrl = 0 && PgUp
				try
					Skip -50
				Catch
					Go top
				Endtry
				m.llGrid = .T.
			Case m.nKeyCode = 3 and m.nShiftAltCtrl = 0 && PgDn
				try
					Skip 50
				Catch
					Go bott
				Endtry
				m.llGrid = .T.
			Case m.nKeyCode = 29 and m.nShiftAltCtrl = 2 && CtrlHome
				Go top
				m.llGrid = .T.
			Case m.nKeyCode = 23 and m.nShiftAltCtrl = 2 && CtrlEnd
				Go bott
				m.llGrid = .T.
		
			Case m.nKeyCode = 13 and m.nShiftAltCtrl = 0 && Enter
				If thisform.lEnter 
					thisform.Release
				else
					thisform.lIncInProcess = .F.
					thisform.doFilterGrid(this.Value)
		*!*				thisform.Grd.SetFocus()
				this.SetFocus()
				Endif
			Case Chr(m.nKeyCode)='*'
				thisform.lIncrementalSeek = !thisform.lIncrementalSeek 
				thisform.chkInc.Refresh() 
				this.Refresh()
			Case Chr(m.nKeyCode)='!'
				thisform.chkUseIndex.Value = !thisform.chkUseIndex.Value 
			Case thisform.lIncrementalSeek
				DoDefault(m.nKeyCode, m.nShiftAltCtrl ) 
					lnSelstart = this.SelStart 
				If Len(Trim(this.Value))>thisform.nIncStart
					thisform.lIncInProcess = .T.
				EndIf
				If thisform.lIncInProcess 
					thisform.doFilterGrid(this.value)
				Endif
					this.SelStart = m.lnSelstart 
				this.SetFocus()
			Otherwise 
				DoDefault(m.nKeyCode, m.nShiftAltCtrl)
		Endcase
		
		If m.llGrid 
			thisform.Grd.Refresh()
			this.SetFocus()
		Endif
		
	ENDPROC

	PROCEDURE txtFind.Refresh
		this.Enabled = !thisform.lMax 
		If thisform.lIncrementalSeek 
			this.BackColor = RGB(255,255,128)
		Else
			this.BackColor = RGB(255,255,255)
		Endif thisform.lIncrementalSeek
		
	ENDPROC

ENDDEFINE
